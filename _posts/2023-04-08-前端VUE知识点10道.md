---
layout:     post
title:      2023/4/8前端VUE知识点
subtitle:   前端VUE经典十个知识点
date:       2023-04-08
author:     YY
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - VUE
---



## 1 vue组件通信

```
props $emit $refs+ref  $children  $parent  bus  作用域插槽slot

```



## 2 vue的api,vue2和vue3的api有没有在官方文档里全部刷一遍

```
遇到问题才会刷

```



## 3 vue中的.keep-alive

```
俗称缓存组件：可以使被包裹的组件不销毁，因此我们可以利用该组件来缓存表单元素客户填写的数据
拥有include、exclude来指明或排除哪些组件是否会缓存
拥有activated与deactivated生命周期函数
缓存原理：
	keep-alive 在内部维护了一个 key 数组和一个缓存对象
	key 数组记录目前缓存的组件 key 值，
    cache 对象会以 key 值为键，vnode 为值（组件对应的虚拟 DOM）

在 keep-alive 的渲染函数中（核心函数（render）），其基本逻辑是判断当前渲染的 vnode 是否有对应的缓存，如果有，会从缓存中读取到对应的组件实例，如果没有就会把它缓存，最后返回vnode，
因此我们用keepalive组件包裹A组件后，从A组件跳转B组件再跳转回来，程序也只会从缓存中取，并不会重新初始化

```



## 4 兄弟组件传参，bus的用法

```
1 引入bus
2 在被传参的组件中注册监听 bus.$on("xx",data=>{})
3 在主动传参的组件中通过bus.$emit(“xx,参数)调用

```



## 5 watch,computed区别

```
watch: 需要配置属性才能立即侦听；支持异步；不带缓存；
computed：首次渲染会立即自动计算一次；不支持异步；带缓存

```



## 6 导航守卫以及应用场景

```
分类：全局导航、路由独享、组件内
场景：发生路由跳转时权限控制

```



## 7 vue2和vue3的区别,为什么vue3打包速度更快

```
1 体积更小：

v3移除了一些不常用的api，比如filter等
Tree Shaking 摇树优化：  按需引入而不是想v2一样引入所有模块
	
	
2  Fragment
模板内不用再创建一个唯一根节点，可以直接放同级标签和内容。就相当于少了一个节点嵌套渲染

3 
	diff 方法的优化：（和虚拟dom相关）
	v2：只要数据发生改变，就会生成一个新的vnode，然后和之前的vnode进行对比，耗时比较多
	v3：创建vnode时会添加一个静态标记，数据改变后带着标记进行对比，能更快找到需要更新的地方
	
	
4 响应式优化
v3的Proxy代理的是整个对象，而v2的Object.defineProperty只代理对象上的某个属性,如果是多层嵌套的数据需要循环递归绑定，耗时>v3
 

```



## 8  vue3proxy的底层原理

```
proxy代理对象 ：我们操作访问的是代理对象，而代理对象才能操作目标对象，可以看成是对操作目标对象的拦击
1 Proxy 可以直接监听对象而非属性；

	(由于 vue2的Object.defineProperty 只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 Proxy 直接代理对象，不需要遍历操作)

2 Proxy 可以直接监听数组的变化
	(vue2无法监听数组下标操作,而proxy可以)


reflect反射对象 ：1 保证this指向正确2 不会因为报错终端进程
```





## 9 什么是异步组件、动态组件

```
动态组件：<component :is="" 
用于组件的切换


异步组件是一个概念,当需要使用时才从服务器加载，通过import加载，其实就是vue的路由懒加载
```



## 10 什么是组件开发和模块开发 

```
组件开发：每一个组件应该包含 布局、样式和js业务，我们封装好后，其他组件或页面可以引入并且使用
模块开发：我们可以自己封装一个方法、对象等数据，通过export暴露出去，这种写法叫做模块开发，然后在其他组件上可以在script 中 通过import 引入我们暴露的数据即可使用

```

